See README.md for general project information.

## Design System

- **Follow the Vira Design System**: All UI/frontend code must follow the guidelines in `DESIGN.md`
- **Use Existing Widgets**: Always check `src/Vira/Widgets.hs` for existing components before creating new ones
- **Design Consistency**: Maintain the established color palette, typography, and spacing patterns
- **Component Naming**: New widgets should follow the `vira[ComponentName]_` naming convention
- **Responsive Design**: Ensure all UI components work across mobile, tablet, and desktop breakpoints

## Coding Guidelines

- Haskell guidelines
    - Use `LambdaCase` wherever possible
    - If a new top-level function is used only in another function, use `where` to define it locally.
    - Fix all GHC warnings.
- Haskell library guidelines
    - We use `relude` as prelude. Thus, prefer relude's functions over Prelude's.
    - We use the `staticWhich` function from the `static` library to refer to runtime dependencies from Nix environment (see how `Vira.Lib.Git` does it for example).
- Project-specific guidelines
    - Everything in `Vira.Lib` are meant to be moved out to 3rd party libraries in future time. They should not depend on Vira types outside of the 'Lib' package.
- Refactoring & design
    - Prefer Juval LÃ¶wy's Volatility-Based Decomposition principle. For details, see https://www.informit.com/articles/article.aspx?p=2995357&seqNum=2
- When updating code (especially styling) keep that in sync with DESIGN.md (bidirectional)

## Running vira

- Vira stores its state in `./state/` directory, and this includes acid-state data as well as autogenerated tls cert files. If you want to run a fresh instance, delete this directory before running vira.
- Before running cabal/nix commands you should kill the `just run` terminal session (otherwise you will see `vira: StateIsLocked` error)

## Testing changes

- When possible, just rely on `cabal build` (or HLS). Running the application (via `cabal run` or `nix run`) should reserved for cases where it is necessary. I prefer a more rapid dev-feedback cycle. Remember, with Haskell when code compiles it usually runs correctly as well. You must fix all GHC warnings introduced by you.

## Your report

- Try to be concise in explaining changes.
